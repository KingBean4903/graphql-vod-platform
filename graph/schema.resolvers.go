package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/KingBean4903/graphql-vod-platform/graph/model"
	"github.com/KingBean4903/graphql-vod-platform/internal/auth"
	"github.com/KingBean4903/graphql-vod-platform/internal/db"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/datatypes"
)

// UploadVideo is the resolver for the UploadVideo field.
func (r *mutationResolver) UploadVideo(ctx context.Context, title string, description *string, url string, metadata map[string]any) (*model.Video, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, errors.New("unauthorized")
	}

	video := db.Video{
		Title:       title,
		Description: description,
		URL:         url,
		Views:       0,
		UserID: userID,
	}

	jsonStr, err := json.Marshal(metadata)
	if err != nil {
		return nil, err
	}
	video.Metadata = datatypes.JSON(jsonStr)

	if err := db.DB.Create(&video).Error; err != nil {
		return nil, err
	}

	var uploader db.User
	if err := db.DB.First(&uploader, "id = ?", userID).Error; err != nil {
		return nil, err
	}

	return &model.Video{
		ID:          video.ID,
		Title:       video.Title,
		Description: video.Description,
		URL:         video.URL,
		Views:       int(video.Views),
		Metadata:    metadata,
		CreatedAt:   video.CreatedAt.Format(time.RFC3339),
		Uploader: &model.User{
			ID:       uploader.ID,
			Username: uploader.Username,
			Email:    uploader.Email,
			Role:     uploader.Role,
		},
	}, nil
}

// PostComment is the resolver for the postComment field.
func (r *mutationResolver) PostComment(ctx context.Context, videoID string, text string) (*model.Comment, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, errors.New("unauthorized")
	}

	// Save comment to DB
	comment := db.Comment{UserID: userID, VideoID: videoID, Text: text}
	if err := db.DB.Create(&comment).Error; err != nil {
		return nil, err
	}

	out := &model.Comment{
		ID:   comment.ID,
		Text: comment.Text,
		User: &model.User{ID: userID},
	}

	cmtStr, err := json.Marshal(out)
	if err != nil {
		return nil, err
	}

	r.PubSub.Publish("video:"+videoID, string(cmtStr))

	return out, nil
}

// LikeVideo is the resolver for the likeVideo field.
func (r *mutationResolver) LikeVideo(ctx context.Context, videoID string) (bool, error) {
	panic(fmt.Errorf("not implemented: LikeVideo - likeVideo"))
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, username string, email string, password string) (*model.AuthResponse, error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return nil, errors.New("Failed to hash password")
	}

	user := db.User{
		Username: username,
		Email:    strings.ToLower(email),
		Password: string(hashedPassword),
	}

	if err := db.DB.Create(&user).Error; err != nil {
		return nil, errors.New("failedto create user")
	}

	token, err := auth.GenerateToken(user.ID)
	if err != nil {
		return nil, err
	}

	return &model.AuthResponse{
		Token: token,
		User: &model.User{
			ID:       user.ID,
			Username: user.Username,
			Email:    user.Email,
			Role:     user.Role,
		},
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthResponse, error) {
	var user db.User
	if err := db.DB.Where("email = ?", strings.ToLower(email)).First(&user).Error; err != nil {
		return nil, errors.New("invalid credentials")
	}

	err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
	if err != nil {
		return nil, errors.New("invalid credentials")
	}

	token, err := auth.GenerateToken(user.ID)
	if err != nil {
		return nil, err
	}

	return &model.AuthResponse{
		Token: token,
		User: &model.User{
			ID:       user.ID,
			Username: user.Username,
			Email:    user.Email,
			Role:     user.Role,
		},
	}, nil
}

// Videos is the resolver for the videos field.
func (r *queryResolver) Videos(ctx context.Context, limit *int, offset *int) ([]*model.Video, error) {

	l := 10
	o := 0

	if limit != nil {
		l = *limit
	}

	if offset != nil {
		o = *offset
	}

	var videos []*db.Video

	if err := r.DB.
		Order("created_at DESC").
		Limit(l).
		Offset(o).
		Preload("Uploader").
		Find(&videos).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch videos: %w", err)
	}

	out := make([]*model.Video, len(videos))

	for i, v := range videos {
		
		var m map[string]any
		
		if err := json.Unmarshal(v.Metadata, &m); err != nil {
				fmt.Println("Failed to umarshal metadata: ", err)
		}

		out[i] = &model.Video{
			ID:          fmt.Sprint(v.ID),
			Title:       v.Title,
			Description: v.Description,
			URL:         v.URL,
			Views:       v.Views,
			Metadata:    m,
			CreatedAt:   v.CreatedAt.Format(time.RFC3339),
			Uploader: &model.User{
				ID:        fmt.Sprint(v.Uploader.ID),
				Username:  v.Uploader.Username,
				Email:     v.Uploader.Email,
				Role:      v.Uploader.Role,
				CreatedAt: v.Uploader.CreatedAt.Format(time.RFC3339),
			},
		}
	}

	return out, nil
}

// Video is the resolver for the video field.
func (r *queryResolver) Video(ctx context.Context, id string) (*model.Video, error) {
	
	var v db.Video

	if err := r.DB.Preload("Uploader").First(&v, "id = ?", id).Error; err != nil {
		return nil, fmt.Errorf("video not found")
	}

  var m map[string]any

	err := json.Unmarshal(v.Metadata, &m)
	if err != nil { 
			fmt.Println("Error unmarshaling metadata", err)
			return nil, err
	}

	return &model.Video{
		ID:          fmt.Sprint(v.ID),
		Title:       v.Title,
		Description: v.Description,
		URL:         v.URL,
		Views:       v.Views,
		Metadata:    m,
		CreatedAt:   v.CreatedAt.Format(time.RFC3339),
		Uploader: &model.User{
			ID:        fmt.Sprint(v.Uploader.ID),
			Username:  v.Uploader.Username,
			Email:     v.Uploader.Email,
			Role:      v.Uploader.Role,
			CreatedAt: v.Uploader.CreatedAt.Format(time.RFC3339),
		},
	}, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: User - user"))
}

// NewComment is the resolver for the newComment field.
func (r *subscriptionResolver) NewComment(ctx context.Context, videoID string) (<-chan *model.Comment, error) {
	topic := "video:" + videoID
	rawCh, err := r.PubSub.Subscribe(topic)
	if err != nil {
		return nil, err
	}

	out := make(chan *model.Comment, 1)
	go func() {
		for {
			select {
			case <-ctx.Done():
				return
			case raw := <-rawCh:
				data := raw.(map[string]any)
				out <- &model.Comment{
					ID:   data["id"].(string),
					Text: data["text"].(string),
					User: &model.User{
						ID: data["user"].(map[string]any)["id"].(string),
					},
				}
			}
		}
	}()

	return out, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
