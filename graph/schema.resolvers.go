package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"encoding/json"
	"strings"
	"errors"
	"fmt"
	"time"

	"github.com/KingBean4903/graphql-vod-platform/graph/model"
	"github.com/KingBean4903/graphql-vod-platform/internal/auth"
	"github.com/KingBean4903/graphql-vod-platform/internal/db"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/datatypes"
)

// UploadVideo is the resolver for the UploadVideo field.
func (r *mutationResolver) UploadVideo(ctx context.Context, title string, description *string, url string, metadata map[string]any) (*model.Video, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, errors.New("unauthorized")
	}

	video := db.Video{
		Title:       title,
		Description: description,
		URL:         url,
		Views:       0,
		//		Metadata:    datatypes.JSON(string(metadata)),
		UserID: userID,
	}

	jsonStr, err := json.Marshal(metadata)
	if err != nil {
		return nil, err
	}
	video.Metadata = datatypes.JSON(jsonStr)

	if err := db.DB.Create(&video).Error; err != nil {
		return nil, err
	}

	var uploader db.User
	if err := db.DB.First(&uploader, userID).Error; err != nil {
		return nil, err
	}

	return &model.Video{
		ID:          string(video.ID),
		Title:       video.Title,
		Description: video.Description,
		URL:         video.URL,
		Views:       int(video.Views),
		Metadata:    metadata,
		CreatedAt:   video.CreatedAt.Format(time.RFC3339),
		Uploader: &model.User{
			ID:       string(uploader.ID),
			Username: uploader.Username,
			Email:    uploader.Email,
			Role:     uploader.Role,
		},
	}, nil
}

// PostComment is the resolver for the postComment field.
func (r *mutationResolver) PostComment(ctx context.Context, videoID string, text string) (*model.Comment, error) {
	userID, ok := auth.GetUserID(ctx)
	if !ok {
		return nil, errors.New("unauthorized")
	}

	// Save comment to DB
	comment := db.Comment{UserID: userID, VideoID: videoID, Text: text}
	if err := db.DB.Create(&comment).Error; err != nil {
		return nil, err
	}


	out := &model.Comment{
		ID:   comment.ID,
		Text: comment.Text,
		User: &model.User{ID: userID},
	}

	cmtStr, err := json.Marshal(out)
	if err != nil {
			return nil, err
	}

	r.PubSub.Publish("video:"+videoID, string(cmtStr))

	return out, nil
}

// LikeVideo is the resolver for the likeVideo field.
func (r *mutationResolver) LikeVideo(ctx context.Context, videoID string) (bool, error) {
	panic(fmt.Errorf("not implemented: LikeVideo - likeVideo"))
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, username string, email string, password string) (*model.AuthResponse, error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return nil, errors.New("Failed to hash password")
	}

	user := db.User{
		Username: username,
		Email:    strings.ToLower(email),
		Password: string(hashedPassword),
	}

	if err := db.DB.Create(&user).Error; err != nil {
		return nil, errors.New("failedto create user")
	}

	token, err := auth.GenerateToken(user.ID)
	if err != nil {
		return nil, err
	}

	return &model.AuthResponse{
		Token: token,
		User: &model.User{
			ID:       user.ID,
			Username: user.Username,
			Email:    user.Email,
			Role:     user.Role,
		},
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthResponse, error) {
	var user db.User
	if err := db.DB.Where("email = ?", strings.ToLower(email)).First(&user).Error; err != nil {
		return nil, errors.New("invalid credentials")
	}

	err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
	if err != nil {
		return nil, errors.New("invalid credentials")
	}

	token, err := auth.GenerateToken(user.ID)
	if err != nil {
		return nil, err
	}

	return &model.AuthResponse{
		Token: token,
		User: &model.User{
			ID:       user.ID,
			Username: user.Username,
			Email:    user.Email,
			Role:     user.Role,
		},
	}, nil
}

// Videos is the resolver for the videos field.
func (r *queryResolver) Videos(ctx context.Context) ([]*model.Video, error) {
	panic(fmt.Errorf("not implemented: Videos - videos"))
}

// Video is the resolver for the video field.
func (r *queryResolver) Video(ctx context.Context, id string) (*model.Video, error) {
	panic(fmt.Errorf("not implemented: Video - video"))
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: User - user"))
}

// NewComment is the resolver for the newComment field.
func (r *subscriptionResolver) NewComment(ctx context.Context, videoID string) (<-chan *model.Comment, error) {
	topic := "video:" + videoID
	rawCh, err := r.PubSub.Subscribe(topic)
	if err != nil {
		return nil, err
	}

	out := make(chan *model.Comment, 1)
	go func() {
		for {
			select {
			case <-ctx.Done():
				return
			case raw := <-rawCh:
				data := raw.(map[string]any)
				out <- &model.Comment{
					ID:   data["id"].(string),
					Text: data["text"].(string),
					User: &model.User{
						ID: data["user"].(map[string]any)["id"].(string),
					},
				}
			}
		}
	}()

	return out, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
